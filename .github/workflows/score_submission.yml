name: Decrypt, Validate, and Evaluate Submission

on:
  pull_request_target:
    paths:
      - "submissions/inbox/**/predictions.csv.enc"
      - "submissions/inbox/**/metadata.json"
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write

jobs:
  score_and_update:
    runs-on: ubuntu-latest
    concurrency:
      group: update-leaderboard
      cancel-in-progress: false
    steps:
      - name: Checkout main branch (target repo)
        uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 0
          path: main_repo

      - name: Checkout PR head branch (submission source)
        uses: actions/checkout@v4
        with:
          repository: ${{ github.event.pull_request.head.repo.full_name }}
          ref: ${{ github.event.pull_request.head.sha }}
          fetch-depth: 0
          path: pr_repo
          persist-credentials: false

      - name: Detect and validate changed files in PR
        id: detect
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const pull_number = context.payload.pull_request.number;

            const files = await github.paginate(github.rest.pulls.listFiles, {
              owner,
              repo,
              pull_number,
              per_page: 100
            });

            const allowed = /^submissions\/inbox\/.+\/.+\/(predictions\.csv\.enc|metadata\.json)$/;
            const blocked = files
              .map(f => f.filename)
              .filter(name => !allowed.test(name));

            if (blocked.length > 0) {
              core.setFailed(
                "This PR can only change submission files.\nBlocked files:\n" + blocked.join("\n")
              );
              return;
            }

            const preds = files
              .map(f => f.filename)
              .filter(name => /^submissions\/inbox\/.+\/.+\/predictions\.csv\.enc$/.test(name));
            const metas = files
              .map(f => f.filename)
              .filter(name => /^submissions\/inbox\/.+\/.+\/metadata\.json$/.test(name));

            if (preds.length !== 1 || metas.length !== 1) {
              core.setFailed(
                `Each PR must include exactly one predictions.csv.enc and one metadata.json. Found encrypted predictions=${preds.length}, metadata=${metas.length}`
              );
              return;
            }

            const predDir = preds[0].split("/").slice(0, -1).join("/");
            const metaDir = metas[0].split("/").slice(0, -1).join("/");
            if (predDir !== metaDir) {
              core.setFailed("predictions.csv.enc and metadata.json must be in the same run folder.");
              return;
            }

            core.setOutput("pred_file", preds[0]);
            core.setOutput("meta_file", metas[0]);
            core.setOutput("run_dir", predDir);



      # Set up Python
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'

      # Install dependencies
      - name: Install dependencies
        run: |
          pip install pandas pyarrow scikit-learn numpy cryptography

      # Clone private test labels repo
      - name: Clone private labels repo
        env:
          LABELS_TOKEN: ${{ secrets.LABELS_TOKEN }}   # PAT with read access to private repo
        run: |
          git clone https://${LABELS_TOKEN}@github.com/jawa-23/GRIT-Secrets.git main_repo/data/private
          
      - name: Get private key and decrypt submission
        env:
          PRIVATE_KEY: ${{ secrets.PRIVATE_KEY }}
        run: |
          set -e
          
          # Write secret to file
          echo "$PRIVATE_KEY" > main_repo/data/private/private_key.pem
          chmod 600 main_repo/data/private/private_key.pem
          
          # Decrypt Predictions
          python main_repo/encryption/decrypt.py \
            "pr_repo/${{ steps.detect.outputs.pred_file }}" \
            "main_repo/data/private/private_key.pem" \
            "main_repo/data/private/predictions_decrypted.csv"
            
          # Check file exists and not empty
          test -s main_repo/data/private/predictions_decrypted.csv
          
      # Validate predictions file
      - name: Validate submission
        run: |
          python main_repo/competition/validate_submission.py \
            "main_repo/data/private/predictions_decrypted.csv" \
            "main_repo/data/public/test_nodes.parquet"
          
      # Evaluate submission
      - name: Run evaluation
        run: |
          python main_repo/competition/evaluate.py \
            "main_repo/data/private/predictions_decrypted.csv" \
            "main_repo/data/private/test_labels.parquet"

      # Read score from score.txt
      - name: Read score
        id: get_score
        run: echo "SCORE=$(cat score.txt)" >> $GITHUB_OUTPUT

      # Update leaderboard CSV
      - name: Update leaderboard CSV
        run: python leaderboard/update_leaderboard_csv.py
        env:
          SCORE: ${{ steps.get_score.outputs.SCORE }}


     # Copy CSV to docs
      - name: Copy CSV to docs
        run: cp leaderboard/leaderboard.csv docs/leaderboard.csv

      - name: Commit leaderboard CSV
        env:
          BOT_TOKEN: ${{ secrets.BOT_TOKEN }}
        run: |
          git config user.name "challenge-bot"
          git config user.email "challenge-bot@users.noreply.github.com"
      
          git add leaderboard/leaderboard.csv docs/leaderboard.csv
      
          if git diff --cached --quiet; then
            echo "No leaderboard changes to commit."
          else
            git commit -m "Update leaderboard"
            git push https://${BOT_TOKEN}@github.com/jawa-23/GRIT-Challenge.git main
          fi

